* add parser
* add repl
* add a_dump()
** add a_stream
** add type.dump_val
*** implement for all types
** add a_stack_dump(ls *self, stream *out);
*** add stack.h/c
*** extract push/pop/peek
* --
* add a_frame struct
** add vm.frames ls
** add return op
*** pop frame
* remove a_func.vm field
** pass args instead
* add vm.form_pool
* add inc/dec funcs to core lib
* add math lib with add/sub/ funcs
* add a_lib_import(lib)
** bind all in current scope
* fib
* ---
* add stack_type
** use val/ls
** add ls_pool
* ---
* add a_pool.full_pages
** rename pages to used_pages
** rename free to free_slots
* sort a_pool.free_slots in size order
** bail out in malloc if > size
** insert where >=
* use data as ls for slots
** add slot data struct 
*** move ls field

(func fibrec [n:Int] [Int]
  (if (< $n 2) $n (+ (fibrec (dec $n)) (fibrec (- $n 2)))))
