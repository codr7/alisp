* fib
** backup/restore arg registers in frame
*** add a_frame.regs
*** use a_store to restore
** drop results from stack in ret op if CALL_DRETS
* add bench prim
* add mem call flag
** add a_lset a_func.memo
*** index on args
*** add if missing
* add tco call flag
** trigger tco
* add separate func stacks
** store in frame
** move args on call
** move rets on return
** add a_ls_splice(self, fst, lst)
* ---
* add unbind prim
** (let [foo 42] (unbind foo) foo)
** add to readme/bindings
* add recoverable errors
** add vm.errors
** add struct a_error like form
** add a_error(vm, type, pos, spec, args)
** replace a_fail-calls
* add iterators
* add strings
* add quoting
** add form.quote1-3
** add '-parser
* add multi support
** create automatically in func prim
** create automatically in lib import
* add test prim
** (test "..." [stack] body)
** add test script
* add line comments with ;
* add support for dynamic lists
** add LS_OP
* capture registers in func, apply/restore in frame
** only those loaded but not stored in body
* ---
* sort a_pool.free_slots in size order
** bail out in malloc if > size
** insert where >=
