* add call parser
* remove a_func.vm field
** pass args instead
* add func prim
** add ls form / parser
** add return op
*** pop frame
** add a_frame struct
*** add vm.frames ls
* add inc/dec funcs to core lib
* add math lib with add/sub/ funcs
* add bench prim
* fib
* ---
* ---
* add a_pool.full_pages
** rename pages to used_pages
** rename free to free_slots
* sort a_pool.free_slots in size order
** bail out in malloc if > size
** insert where >=
* use data as ls for slots
** add slot data struct 
*** move ls field

(func fibrec [n:Int] [Int]
  (if (< $n 2) $n (+ (fibrec (dec $n)) (fibrec (- $n 2)))))

public func intReader(_ p: Parser) throws -> Form? {
    let fpos = p.pos
    var v = 0
    var neg = false
    
    let c = p.getc()
    if c == nil { return nil }
    
    if c == "-" {
        if let c = p.getc() {
            if c.isNumber {
                neg = true
            } else {
                p.ungetc(c)
                p.ungetc("-")
            }
        }
    } else {
        p.ungetc(c!)
    }
    
    while let c = p.getc() {
        if !c.isNumber {
            p.ungetc(c)
            break
        }
            
        v *= 10
        v += c.hexDigitValue!
        p.nextColumn()
    }
        
    return (p.pos == fpos) ? nil : LiteralForm(env: p.env, pos: p.pos, p.env.coreLib!.intType, neg ? -v : v)
}
