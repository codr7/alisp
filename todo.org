* analyze rets
** add bool ret_op.check
*** default true
*** extract logic
**** disable check if ok
* add optional type to load op
** check on eval if set
** use in op_analyze
** go through code and look for load ops in a_func_end
*** set type if matches args reg
* --
* add separate func stacks
** store in frame
** move args on call
** move rets on returnb
** add a_ls_splice(self, fst, lst)
* add func op
** replaces skip goto in body
** reset & push unnamed args in analyze
* add registers to analyze
** backup/restore
** set/get in store/load
** clear on barrier/func/goto/ret/stop
* add memoize/m call flag
** add a_lset a_func.mem
*** index on args
*** add if missing
* add tco/t call flag
** trigger tco
* capture stored registers in func
** scan code for STORE & push reg
* add test prim
** (test "..." [stack] body)
** add test script
* add strings
* add iterators
* add or/and prims
* add unbind prim
** (let [foo 42] (unbind foo) foo)
** add to readme/bindings
* add recoverable errors
** add vm.errors
** add struct a_error like form
** add a_error(vm, type, pos, spec, args)
** replace a_fail-calls
* add quoting
** add form.quote1-3
** add '-parser
* add multi support
** create automatically in func prim
** create automatically in lib import
* add line comments with ;
* add support for dynamic lists
** add LS_OP
* ---
* sort a_pool.free_slots in size order
** bail out in malloc if > size
** insert where >=
* add unsafe/u call flag
** skip arg/ret checks

(func fibrecs [Int] [Int]
   (cp) (if _.(< 2) _ (do 
                         _.(- 1) (cp) 
                         _.(fibrecs) 
                         (swap) _.(- 1) 
                         _.(fibrecs)
                         _.(+ _)))))
