* specialize multi calls in a_op_analyze
* add a_task
** bool done
** ls args
** func body
** add vm.tasks
** add yield prim
* --
* add type-of/isa prims
** readme/types
* add quoting
** add a_form_dump
** add a_val *a_form_quote(form, vm)
*** form_val if available
*** default quote form
**** add form type
**** add A_QUOTE_FORM
*** sym if id
**** add a_sym_type
**** add lset vm.syms
***** check in a_sym()
** add '-parser
* add bool a_feval(vm, path)
** add stream vm.path
** add int a_push_path
** add a_pop_path(int)
** process ARGV & load files instead of repl
* add separate func stacks
** store in frame
** move args on call
** move rets on returnb
** add a_ls_splice(self, fst, lst)
* add test prim
** (test "..." [stack] body)
** add test script
* add lambdas
** ([x:Int] [Int] x)
** capture in call parse
** extract a_parse_func
** change capture example in readme
* add func op
** replaces skip goto in body
** reset & push unnamed args in analyze
* add registers to analyze
** backup/restore
** set/get in store/load
** clear on fence/func/goto/ret/stop
* capture stored registers in func
** scan code for STORE & push reg
* add strings
* add iterators
* add or/and prims
* add unbind prim
** (let [foo 42] (unbind foo) foo)
** add to readme/bindings
* add recoverable errors
** add vm.errors
** add struct a_error like form
** add a_error(vm, type, pos, spec, args)
** replace a_fail-calls
* add line comments with ;
* add support for dynamic lists
** add LS_OP
* add once prim
** add A_ONCE_OP
*** emit like bench
** keep internal val in op
** set on first eval
* add unsafe/u call flag
** skip arg/ret checks
* add macros
** rewrite def as macro

(func map [in:List t:Target] [List]
  (func helper [in:Any out:Any] [List]
    (if (nil? in)
      (reverse out)
      (helper:t (tail in) (t (head in)):out)))
  (helper:t in NIL))
(func foo [Int] [Int] _.(+ 1))
(map [1 2 3 4 5] foo)	
