* implement iter_val for Int
* add map iter
* add for prim
* --
* bayes
** build/x.lisp
** add *(float int)
** add /(float int)
* add import prim
** add lib type
** bind abc/math
** don't include anything automatically in scripts
** change a_lib_import to take single string arg
*** extract a_lib_import_all
* add or/and prims
* add io.open
** add enums
*** (enum OpenMode RD RW RD-OW APP RD-APP)
** add R/W/RWFile
* add tasks
** struct a_task
** bool done
** ls args
** func body
** add vm.tasks
** add yield prim
* add type-of/isa prims
** readme/types
* add quoting
** add a_form_dump
** add a_val *a_form_quote(form, vm)
*** form_val if available
*** default quote form
**** add form type
**** add A_QUOTE_FORM
*** sym if id
**** add a_sym_type
**** add lset vm.syms
***** check in a_sym()
** add '-parser
** add string refcounting
*** switch pos source to sym
* add separate func stacks
** store in frame
** move args on call
** move rets on returnb
** add a_ls_splice(self, fst, lst)
* add func op
** replaces skip goto in body
** reset & push unnamed args in analyze
* capture stored registers in func
** scan code for STORE & push reg
* add recoverable errors
** add vm.errors
** add struct a_error like form
** add a_error(vm, type, pos, spec, args)
** replace a_fail-calls
* add line comments with ;
* add support for dynamic lists
** add LS_OP
* add once prim
** add A_ONCE_OP
*** emit like bench
** keep internal val in op
** set on first eval
* add unsafe/u call flag
** skip arg/ret checks
* add macros
** rewrite def as macro
* add binding pool
** add vm.free_bindings like val
** use in scope/lib
** extract a_binding()/a_binding_free()
* add scope pool
** vm.free_scopes like val
* handle register target inside call op
** replace LOAD in call form emit

(defun bayesian-spam-probability (feature &optional
                                  (assumed-probability 1/2)
                                  (weight 1))
  (let ((basic-probability (spam-probability feature))
        (data-points (+ (spam-count feature) (ham-count feature))))
    (/ (+ (* weight assumed-probability)
          (* data-points basic-probability))
       (+ weight data-points))))

(defun fisher (probs number-of-probs)
  "The Fisher computation described by Robinson."
  (inverse-chi-square 
   (* -2 (log (reduce #'* probs)))
   (* 2 number-of-probs)))

(defun inverse-chi-square (value degrees-of-freedom)
  (assert (evenp degrees-of-freedom))
  (min 
   (loop with m = (/ value 2)
      for i below (/ degrees-of-freedom 2)
      for prob = (exp (- m)) then (* prob (/ m i))
      summing prob)
   1.0))



